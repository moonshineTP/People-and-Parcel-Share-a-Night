from typing import List, Tuple


# ----- file oj.py begin -----
"""
    Dedicated for online judge systems submission.
    Use inliner.py for inlining modules of this file into one file.
    The final output is submission.py
"""
import sys


# ----- file share_a_ride/solvers/algo/Algo.py begin -----
from typing import Callable, Dict, Any, List, Optional, Tuple


# ----- file share_a_ride/problem.py begin -----
"""
Module defining the Share-a-Ride Problem (SARP) class and related functionalities.
"""



class ShareARideProblem:
    def __init__(
            self, N: int, M: int, K: int,
            parcel_qty: List[int], vehicle_caps: List[int],
            dist: List[List[int]], coords: Optional[List[Tuple[int, int]]] = None
        ):

        # Basic parameters
        self.N = N
        self.M = M
        self.K = K
        self.q = list(parcel_qty)
        self.Q = list(vehicle_caps)
        self.D = [row[:] for row in dist]
        self.num_nodes = 2*N + 2*M + 1
        self.num_requests = N + M

        # index helpers
        self.ppick = lambda i: i
        self.pdrop = lambda i: N + M + i
        self.parc_pick = lambda j: N + j
        self.parc_drop = lambda j: 2*N + M + j

        self.rev_ppick = lambda i: i
        self.rev_pdrop = lambda n: n - (N + M)
        self.rev_parc_pick = lambda n: n - N
        self.rev_parc_drop = lambda n: n - (2 * N + M)

        # Node check helpers
        self.is_ppick = lambda x: 1 <= x <= N
        self.is_pdrop = lambda x: N + M + 1 <= x <= 2 * N + M
        self.is_parc_pick = lambda x: N + 1 <= x <= N + M
        self.is_parc_drop = lambda x: 2 * N + M + 1 <= x <= 2 * (N + M)

        # Coordinate (mainly for visualization)
        self.coords = coords


    def is_valid(self) -> bool:
        try:
            assert len(self.q) == self.M
            assert len(self.Q) == self.K
            assert len(self.D) == self.num_nodes
            assert all(len(row) == self.num_nodes for row in self.D)
            assert len(self.coords) == self.num_nodes \
                if self.coords is not None else True

            return True
        except:
            return False

    def copy(self):
        return ShareARideProblem(self.N, self.M, self.K,
            list(self.q), list(self.Q), [row[:] for row in self.D]
        )


    def stdin_print(self):
        print(self.N, self.M, self.K)
        print(*self.q)
        print(*self.Q)
        for row in self.D:
            print(*row)


    def pretty_print(self, verbose: bool = False):
        print(f"Share-a-Ride: N={self.N} passengers, M={self.M} parcels, "
            f"K={self.K}, num_nodes={self.num_nodes}")

        if verbose >= 1:
            print("Parcel quantities (q):", self.q)
            print("Vehicle capacities (Q):", self.Q)
            print("Distance matrix D:")
            for row in self.D:
                print(" ", row)


    def to_sarp_text(self) -> str:
        dimension = self.num_nodes

        if not self.is_valid():
            raise ValueError("Instance data is invalid.")
        if self.coords is None:
            raise ValueError("Coordinates are required for SARP text export.")

        name = getattr(self, "name", "Generated_SARP")
        comment = getattr(self, "comment", f"Generated by 'share_a_ride.util.generator. "
                            f"Node count: N={self.N}, M={self.M}, K={self.K}")

        lines: List[str] = []
        lines.append(f"NAME : {name}")
        lines.append(f"COMMENT : {comment}")
        lines.append("TYPE : SARP")
        lines.append(f"DIMENSION : {dimension}")
        lines.append("EDGE_WEIGHT_TYPE : EXPLICIT")
        lines.append("EDGE_WEIGHT_FORMAT : FULL_MATRIX")
        if len(set(self.Q)) == 1:
            lines.append(f"CAPACITY : {self.Q[0]}")

        lines.append("")
        lines.append("EDGE_WEIGHT_SECTION")
        for row in self.D:
            lines.append(" ".join(str(value) for value in row))
        lines.append("EOF_EDGE_WEIGHT_SECTION")

        lines.append("")
        lines.append("NODE_COORD_SECTION")
        for idx, (x, y) in enumerate(self.coords, start=1):
            lines.append(f"{idx} {x} {y}")
        lines.append("EOF_NODE_COORD_SECTION")

        lines.append("")
        lines.append("NODE_TYPE_SECTION")
        for idx in range(dimension):
            node_id = idx + 1
            if idx == 0:
                node_type = 0
            elif self.is_ppick(idx):
                node_type = 1
            elif self.is_parc_pick(idx):
                node_type = 2
            elif self.is_pdrop(idx):
                node_type = 3
            elif self.is_parc_drop(idx):
                node_type = 4
            else:
                raise ValueError("Invalid node index encountered.")
            
            lines.append(f"{node_id} {node_id} {node_type}")
        lines.append("EOF_NODE_TYPE_SECTION")

        lines.append("")
        lines.append("PAIR_SECTION")
        pair_id = 1
        for i in range(1, self.N + 1):
            pickup = self.ppick(i) + 1
            drop = self.pdrop(i) + 1
            lines.append(f"{pair_id} {pickup} P {drop}")
            pair_id += 1
        for j in range(1, self.M + 1):
            pickup = self.parc_pick(j) + 1
            drop = self.parc_drop(j) + 1
            lines.append(f"{pair_id} {pickup} L {drop}")
            pair_id += 1
        lines.append("EOF_PAIR_SECTION")

        lines.append("")
        lines.append("VEHICLE_CAPACITY_SECTION")
        for vehicle_id, cap in enumerate(self.Q, start=1):
            lines.append(f"{vehicle_id} {vehicle_id} {cap}")
        lines.append("EOF_VEHICLE_CAPACITY_SECTION")

        lines.append("")
        lines.append("PARCEL_QUANTITY_SECTION")
        for idx, qty in enumerate(self.q, start=1):
            pickup = self.parc_pick(idx) + 1
            lines.append(f"{idx} {pickup} {qty}")
        lines.append("EOF_PARCEL_QUANTITY_SECTION")

        lines.append("")
        lines.append("DEPOT_SECTION")
        lines.append("1")
        lines.append("EOF_DEPOT_SECTION")

        lines.append("")
        lines.append("EOF")

        return "\n".join(lines) + "\n"


# ----- file share_a_ride/problem.py end -----

from typing import List

# ---------------------- Helper functions ----------------------------------------
def route_cost_from_sequence(
        seq: List[int], 
        D: List[List[int]], 
        verbose: bool = False
    ) -> int:

    assert seq and seq[0] == 0

    prev, total_cost = 0, 0
    for node in seq[1:]:
        if verbose: 
            print(D[prev][node], end=" ")

        total_cost += D[prev][node]
        prev = node
   
    if verbose:
        print()

    return total_cost


class Solution:
    """
    Solution object representing K routes.
    - routes: list of lists of node indices (each route includes depot 0 at start and end)
    - route_lengths: list of ints
    - max_length: int (objective to minimize)
    """
    def __init__(self, problem: ShareARideProblem,
                routes: List[List[int]], route_costs: Optional[List[int]] = None):

        if problem is None:
            raise ValueError("Problem instance cannot be None.")

        assert len(routes) == len(route_costs)
        self.problem = problem
        self.routes = routes
        self.route_costs = route_costs
        if route_costs is None:
            route_costs = [
                route_cost_from_sequence(route, problem.D) 
                for route in routes
            ]
        self.max_cost = max(route_costs) if route_costs else 0


    def is_valid(self) -> bool:
        """
            Check depot, precedence, and capacity constraints.
        """

        prob = self.problem
        N, M, K = prob.N, prob.M, prob.K
        if len(self.routes) != K:
            return False

        for route_idx, route in enumerate(self.routes):
            # must start and end at depot
            if not (route[0] == 0 and route[-1] == 0):
                return False

            # track passengers and parcels
            passenger_onboard = set()
            parcel_onboard = set()
            parcel_load = 0

            visited_pass_pick = set()
            visited_parc_pick = set()

            for node in route[1:-1]:

                # passenger pickup
                if prob.is_ppick(node):
                    id = prob.rev_ppick(node)

                    # check
                    if id in visited_pass_pick:
                        return False
                    if len(passenger_onboard) >= 1:
                        return False

                    # add
                    passenger_onboard.add(id)
                    visited_pass_pick.add(id)

                # passenger drop
                elif prob.is_pdrop(node):
                    id = prob.rev_pdrop(node)

                    # check
                    if id not in passenger_onboard:
                        return False

                    # remove
                    passenger_onboard.remove(id)

                # parcel pickup
                elif prob.is_parc_pick(node):
                    jd = prob.rev_parc_pick(node)

                    # check
                    if jd in visited_parc_pick or jd in parcel_onboard:
                        return False
                    parcel_load += prob.q[jd - 1]
                    if parcel_load > prob.Q[route_idx]:
                        return False

                    # add
                    visited_parc_pick.add(jd)
                    parcel_onboard.add(jd)

                # parcel drop
                elif prob.is_parc_drop(node):
                    jd = prob.rev_parc_drop(node)

                    # check
                    if jd not in parcel_onboard:
                        return False

                    # remove
                    assert parcel_load - prob.q[jd - 1] >= 0
                    parcel_load -= prob.q[jd - 1]
                    parcel_onboard.remove(jd)

            # at end of route
            if passenger_onboard:
                return False
            if parcel_load != 0:
                return False

        return True


    def stdin_print(self, verbose: int = 0):
        """
            Print the solution in the specified format.
            Verbose option for more details.
            - verbose=0: for online judge
            - verbose=1: detailed route info
        """
        if verbose:
            print(f"*** Max route cost: {self.max_cost} ***")

        print(self.problem.K)

        for route, cost in zip(self.routes, self.route_costs):
            if verbose:
                print(f"- Route cost: {cost}")
            print(len(route))
            print(" ".join(map(str, route)))


    def file_print(self, file_path: str):
        """
        Print solution to a .sol file in the TSPLIB format.
        Remember that TSPLIB .sol format exclude depot 1 in the route.
        """
        with open(file_path, 'w') as f:
            for i, route in enumerate(self.routes):
                route_str = ' '.join(map(str, route[1:-1]))
                f.write(f"Route #{i + 1}: {route_str}\n")

            f.write(f"Cost {self.max_cost}\n")




class PartialSolution:
    """
    PartialSolution object representing a partial assignment of nodes to K routes.
    Used for constructive heuristics and branch-and-bound algorithms.

    Attributes:
    - problem: ShareARideProblem instance
    - routes: list of lists of node indices (partial routes, always start with depot 0)
    - premature_routes: copy of the current routes to resume greedy extensions
    - route_costs: list of current route costs
    - max_cost: maximal route cost among current routes
    - node_assignment: list mapping each node to its assigned route
        following -1 for unassigned, 0..K-1 for assigned to route, depot 0 is undefined
    - route_states / taxi_states: list of dicts holding per-route state
        ({route, pos, cost, load, passenger, parcels, ended})
    - remaining_pass_pick: set of passenger ids whose pickup has not been scheduled
    - remaining_pass_drop: set of passenger ids picked but not dropped yet
    - remaining_parc_pick: set of parcel ids whose pickup has not been scheduled
    - remaining_parc_drop: set of parcel ids picked but not dropped yet
    """

    def __init__(
            self,
            problem: ShareARideProblem,
            routes: List[List[int]] = [],
        ):
        """
        Initialize PartialSolution with problem and given route list.
        If routes are provided, validate them.
        Else, initialize K empty routes starting at depot 0.
        """

        if problem is None:
            raise ValueError("Problem instance cannot be None.")

        # Initialize route and route costs
        self.problem = problem
        self.routes = self._init_routes(routes)
        self.route_costs = self._init_costs(routes)

        self.max_cost = max(self.route_costs)
        self.node_assignment = self._init_node_assignment()
        (   self.remaining_pass_pick, self.remaining_pass_drop, self.remaining_parc_pick,
            self.remaining_parc_drop, self.route_states
        ) = self._init_states()


    def _init_routes(self, routes):
        K = self.problem.K

        # Validating
        if routes is None:
            return [[0] for _ in range(K)]
        if len(routes) != K:
            raise ValueError(f"Expected {K} routes, got {len(routes)}.")
        for route in routes:
            if not route:
                raise ValueError("One route cannot be null")
            if route[0] != 0:
                raise ValueError("Each route must start at depot 0.")

        return routes


    def _init_costs(self, routes):
        # Validating
        if routes is None:
            return [0] * self.problem.K
        if len(routes) != self.problem.K:
            raise ValueError("Mismatch between routes and route_costs length.")

        return [route_cost_from_sequence(route, self.problem.D) for route in routes]


    def _init_node_assignment(self):
        node_count = len(self.problem.D)
        assignment = [-1] * node_count
        for idx, route in enumerate(self.routes):
            for node in route[1:]:
                if node == 0 or node >= node_count:
                    continue
                assignment[node] = idx
        return assignment


    def _init_states(self):
        prob = self.problem

        # Initialize remaining pickups and drops, and taxi states
        remaining_pass_pick = set(range(1, prob.N + 1))
        remaining_pass_drop = set()
        remaining_parc_pick = set(range(1, prob.M + 1))
        remaining_parc_drop = set()
        route_states = []

        for idx, route in enumerate(self.routes):
            onboard_passenger = 0
            onboard_parcels = set()
            current_load = 0

            for node in route[1:]:
                if prob.is_ppick(node):
                    pid = prob.rev_ppick(node)
                    remaining_pass_pick.discard(pid)
                    remaining_pass_drop.add(pid)
                    onboard_passenger = pid
                elif prob.is_pdrop(node):
                    pid = prob.rev_pdrop(node)
                    remaining_pass_drop.discard(pid)
                    if onboard_passenger == pid:
                        onboard_passenger = 0
                elif prob.is_parc_pick(node):
                    jid = prob.rev_parc_pick(node)
                    remaining_parc_pick.discard(jid)
                    remaining_parc_drop.add(jid)
                    onboard_parcels.add(jid)
                    current_load += prob.q[jid - 1]
                elif prob.is_parc_drop(node):
                    jid = prob.rev_parc_drop(node)
                    if jid in onboard_parcels:
                        onboard_parcels.remove(jid)
                        current_load -= prob.q[jid - 1]
                    remaining_parc_drop.discard(jid)

            pos = route[-1]
            ended = len(route) > 1 and route[-1] == 0
            state = {
                "route": route,
                "pos": pos,
                "cost": self.route_costs[idx],
                "load": current_load,
                "passenger": onboard_passenger,
                "parcels": set(onboard_parcels),
                "ended": ended
            }
            route_states.append(state)

        return (
            remaining_pass_pick,
            remaining_pass_drop,
            remaining_parc_pick,
            remaining_parc_drop,
            route_states
        )


    def copy(self):
        return PartialSolution(
            problem=self.problem,
            routes=[list(route) for route in self.routes]
        )
    

    def possible_actions(self, t_idx: int) -> List[tuple[str, int, int]]:
        state = self.route_states[t_idx]
        if state["ended"]:
            return []

        prob = self.problem
        pos = state["pos"]
        actions: List[tuple[str, int, int]] = []

        if state["passenger"] == 0:
            for pid in list(self.remaining_pass_pick):
                inc = prob.D[pos][prob.ppick(pid)]
                actions.append(("pickP", pid, inc))
        else:
            pid = state["passenger"]
            inc = prob.D[pos][prob.pdrop(pid)]
            actions.append(("dropP", pid, inc))

        for jid in list(self.remaining_parc_pick):
            parcel_weight = prob.q[jid - 1]
            if state["load"] + parcel_weight <= prob.Q[t_idx]:
                inc = prob.D[pos][prob.parc_pick(jid)]
                actions.append(("pickL", jid, inc))

        for jid in list(state["parcels"]):
            inc = prob.D[pos][prob.parc_drop(jid)]
            actions.append(("dropL", jid, inc))

        return actions


    def apply_action(self, t_idx: int, kind: str, node_idx: int, inc: int) -> None:
        state = self.route_states[t_idx]
        if state["ended"]:
            raise ValueError(f"Cannot apply action on ended route {t_idx}.")

        prob = self.problem

        if kind == "pickP":
            if state["passenger"] != 0:
                raise ValueError(f"Taxi {t_idx} already has passenger {state['passenger']}.")
            node = prob.ppick(node_idx)
            state["passenger"] = node_idx
            self.remaining_pass_pick.discard(node_idx)
            self.remaining_pass_drop.add(node_idx)

        elif kind == "dropP":
            if state["passenger"] != node_idx:
                raise ValueError(f"Taxi {t_idx} is not carrying passenger {node_idx}.")
            node = prob.pdrop(node_idx)
            state["passenger"] = 0
            self.remaining_pass_drop.discard(node_idx)

        elif kind == "pickL":
            parcel_weight = prob.q[node_idx - 1]
            if state["load"] + parcel_weight > prob.Q[t_idx]:
                raise ValueError(f"Taxi {t_idx} capacity exceeded for parcel {node_idx}.")
            node = prob.parc_pick(node_idx)
            state["load"] += parcel_weight
            state["parcels"].add(node_idx)
            self.remaining_parc_pick.discard(node_idx)
            self.remaining_parc_drop.add(node_idx)

        elif kind == "dropL":
            if node_idx not in state["parcels"]:
                raise ValueError(f"Taxi {t_idx} does not carry parcel {node_idx}.")
            node = prob.parc_drop(node_idx)
            state["load"] -= prob.q[node_idx - 1]
            state["parcels"].discard(node_idx)
            self.remaining_parc_drop.discard(node_idx)

        else:
            raise ValueError(f"Unknown action kind: {kind}")

        state["route"].append(node)
        state["cost"] += inc
        state["pos"] = node
        self.node_assignment[node] = t_idx
        self.route_costs[t_idx] = state["cost"]
        self.max_cost = max(self.max_cost, state["cost"])


    def apply_return_to_depot(self, t_idx: int) -> None:
        state = self.route_states[t_idx]

        # Check if route already ended
        if state["ended"]:
            return
        if state["pos"] == 0 and len(state["route"]) > 1:
            state["ended"] = True
            return

        # Ensure taxi is empty before returning to depot
        if state["passenger"] != 0 or state["parcels"]:
            raise ValueError(f"Taxi {t_idx} must drop all loads before returning to depot.")

        # Update state to end route
        state["cost"] += self.problem.D[state["pos"]][0]
        self.route_costs[t_idx] = state["cost"]
        self.max_cost = max(self.max_cost, state["cost"])
        state["route"].append(0)
        state["pos"] = 0
        state["ended"] = True
        


    def is_complete(self) -> bool:
        return all(state["ended"] for state in self.route_states)


    def to_solution(self) -> Optional[Solution]:
        """
        Convert the PartialSolution to a full Solution if complete.
        """
        if not self.is_complete():
            print("Cannot convert to Solution: not all routes have ended at depot.")
            return None

        solution = Solution(
            problem=self.problem,
            routes=self.routes,
            route_costs=self.route_costs
        )
        
        if not solution.is_valid():
            print("Warning: Converted solution is not valid.")

        return solution



class SolutionSwarm:
    """
    SolutionSwarm representing a collection of solutions.
    Used for population-based metaheuristics.
    """

    def __init__(self, solutions: List[Solution]):
        """
        Initialize SolutionSwarm with a list of Solution objects.
        """
        if not solutions:
            raise ValueError("Solutions list cannot be empty.")
        self.solutions = solutions
        self.min_cost = min(sol.max_cost for sol in solutions)
        self.best_solution = min(solutions, key=lambda s: s.max_cost)
        self.avg_cost = sum(sol.max_cost for sol in solutions) / len(solutions)


        
# ----- file share_a_ride/solution.py end -----


algo_name = {
    # Exact
    "exhaustive_solver" : "Exhaustive",
    "branch_and_bound_solver" :"Branch and Bound",
    "milp_solver" : "MILP",
    "cp_solver" : "CP",

    # Metaheuristics
    "greedy_balanced_solver" : "Greedy Balanced",
    "iterative_greedy_balanced_solver" : "Iterative Greedy Balanced",
}


def algo_name_router(solver: Callable) -> str:
    """
    Return the name of the algorithm-based solver.
    """
    try:
        return algo_name[solver.__name__]
    except KeyError:
        raise ValueError(f"Unknown solver: {solver.__name__}")


class AlgoSolver():
    """
    Container for algorithm-based solvers in the share_a_ride problem.
    """
    def __init__(
            self, problem: Optional[ShareARideProblem] = None,
            algo: Optional[Callable[..., Tuple[Optional[Solution], Dict[str, Any]]]] = None,
            args: Dict[str, Any] = {},
            hyperparams: Dict[str, Any] = {},
        ):
        """
        Initialize the solver with problem instance and common parameters.
        Params:
            - problem: ShareARideProblem instance to solve
            - algo: Callable implementing the solving algorithm
            - args: Additional arguments for the algorithm
                (e.g. time_limit, verbose, seed)
            - hyperparams: Dictionary of algorithm-specific hyperparameters
                (e.g. T, steps, ratio, policy model, etc.)
        Optionals:
            - desc: Description of the solver
            - hyperparams: Dictionary of algorithms hyperparameters (if applicable)
        """
        # Solver state
        self.algo = algo
        self.args = args or {}
        self.hyperparams = hyperparams or {}

        # Metadata
        self.name = algo_name_router(algo)
        self.desc = f"{self.name} Solver"


    def solve(
            self,
            problem: ShareARideProblem
        ) -> Tuple[Optional[Solution], Dict[str, Any]]:
        """
        Main solving method to execute the solver.
        Params:
            - problem: ShareARideProblem instance to solve
        Returns: (solution, info): tuple where
        - solution: Best Solution object found (or None if none found)
        - info: Dictionary with statistics including:
            + elapsed_time: Total time taken
            + status: "done" or "timeout"
            + solver-specific metrics
        """
        sol, info = self.algo(problem, **self.args, **self.hyperparams)

        return sol, info


    def save(self, filepath: str) -> None:
        """
        Save the solver configuration to a file.
        
        Params:
            - filepath: Path to save the solver configuration
        """
        pass


    def load(self, filepath: str) -> None:
        """
        Load the solver configuration from a file.
        
        Params:
            - filepath: Path to load the solver configuration from
        """
        pass


class HybridAlgoSolver():
    pass

# ----- file share_a_ride/solvers/algo/Algo.py end -----

# ----- file share_a_ride/solvers/algo/greedy.py begin -----
"""
Greedy balanced heuristic and its iterative improvement.
"""

import time, random
from typing import Any, List, Optional, Tuple, Dict

# ----- file share_a_ride/solvers/operator/build.py begin -----
import random
from typing import Tuple, Optional


# ----- file share_a_ride/solvers/utils/sampler.py begin -----
"""
Helper functions for sampling in solvers/operators.
"""

from typing import List

def sample_from_weight(rng: random.Random, weights: List[float]) -> int:
    """
    Sample an index from a list of weights using Knuth's algorithm.
    Returns the selected index.
    """
    total_weight = sum(weights)

    if total_weight < 1e-10:    # All weights zero: pick uniformly
        res_idx = rng.randrange(len(weights))
    else:                       # Weighted random selection
        rand_val = rng.random() * total_weight
        cumsum = 0.0
        res_idx = 0
        for i, weight in enumerate(weights):
            cumsum += weight
            if rand_val <= cumsum:
                res_idx = i
                break

    return res_idx

# ----- file share_a_ride/solvers/utils/sampler.py end -----

# ----- file share_a_ride/solvers/utils/weighter.py begin -----
"""
Utility functions to compute weights from some score lists.
"""

from typing import List



def softmax_weighter(incs: List[float], T: float) -> List[float]:
    """
    Given a list of incremental costs, compute weights using a temperature-scaled softmax.
    Lower increments get higher weights. If all increments are similar, returns uniform weights.
    """
    min_inc, max_inc = min(incs), max(incs)
    inc_range = max_inc - min_inc

    if inc_range < 1e-6:     # All increments similar: uniform weights
        return [1.0] * len(incs)

    # Else, softmax weights
    weights = []
    for inc in incs:
        normalized = (inc - min_inc) / inc_range
        weights.append((1.0 - normalized + 0.1) ** (1.0 / T))

    return weights

# ----- file share_a_ride/solvers/utils/weighter.py end -----


def build_operator(
        partial: PartialSolution,
        route_idx: int,
        steps: int = 5,
        T: float = 1.0,
        seed: Optional[int] = 42,
        verbose: bool = False
    ) -> Tuple[PartialSolution, int]:
    """
    Expand a partial route directly on the given PartialSolution by applying up to
    ``steps`` feasible actions. 
    Use softmax weighting controlled by ``T`` to favor lower incremental travel cost. 
    Returns the updated PartialSolution and the number of new nodes added to the route.
    """

    assert steps > 0, "Number of steps must be positive."
    assert T > 1e-5, "Temperature T must be positive."

    rng = random.Random(seed)
    added_nodes = 0  # count of newly added nodes (actions applied)

    # Main building loop
    for _ in range(steps):
        state = partial.route_states[route_idx]
        if state["ended"]:
            break

        actions = partial.possible_actions(route_idx)
        if verbose:
            print(f"[build] route {route_idx} available actions: {actions}")

        if not actions:
            if verbose:
                print(f"[build] route {route_idx} has no feasible actions, ending.")

                partial.apply_return_to_depot(route_idx)
                added_nodes += 1
                break

        incs = [action[2] for action in actions]
        weights = softmax_weighter(incs, T)
        selected_idx = sample_from_weight(rng, weights)

        kind, node_idx, inc = actions[selected_idx]

        if verbose:
            print(f"[build] route {route_idx} selected action: {actions[selected_idx]}")

        partial.apply_action(route_idx, kind, node_idx, inc)
        added_nodes += 1


    if verbose:
        print(f"[build] route {route_idx} finished building, added {added_nodes} nodes.")

    return partial, added_nodes

# ----- file share_a_ride/solvers/operator/build.py end -----

# ----- file share_a_ride/solvers/operator/destroy.py begin -----

from typing import List, Tuple




def destroy_one_route(
        route: List[int],
        route_idx: int,
        steps: int = 10,
        verbose: bool = False
    ) -> List[int]:
    """
    Remove a suffix of the given route (keeping the starting depot).
    The resulting route is still a valid partial route.
    """

    res_route = route[:-1]                              # Exclude the ending depot
    remove_len = min(steps, max(0, len(res_route) - 1)) # Ensure at least the starting depot remains
    if remove_len <= 0:
        return route[:]

    suffix_start = len(res_route) - remove_len
    destroyed_route = res_route[:suffix_start]
    if not destroyed_route:
        destroyed_route = [0]

    if verbose:
        print(f"[Operator: Destroy]: last {remove_len} nodes from route {route_idx} removed.")

    return destroyed_route



def destroy_operator(
        sol: Solution,
        destroy_proba: float,
        destroy_steps: int,
        seed: int = 42,
        T: float = 1.0
    ) -> Tuple[PartialSolution, List[bool], int]:
    """
    Select a subset of routes to destroy based on their cost
    The selection use a temperature-based heuristic with probabilities    
    Temperature controls the selection bias:
    - temperature = 0: always select the most expensive routes (greedy)
    - temperature → ∞: uniform random selection
    - temperature = 1: balanced probabilistic selection    
    Higher cost routes have higher probability of being selected, but with
    some randomness to allow exploration.
    
    Args:
        prob: ShareARideProblem instance
        sol: Current solution
        destroy_proba: Fraction of routes to destroy (0 to 1)
        destroy_steps: Maximum number of nodes to remove per route
        seed: for reproducibility
        temperature: Controls selection randomness (default 1.0)
    
    Returns:
        (partial_sol, flags, num_removed): 
            - partial_sol: The modified partial solution after destruction
            - flags: Boolean list indicating which routes were destroyed
            - num_removed: Total number of nodes removed
    """
    rng = random.Random(seed)

    routes = [route[:] for route in sol.routes]
    costs = sol.route_costs
    flags = [False] * len(routes)
    num_removed = 0

    if not routes:
        return PartialSolution(problem=sol.problem, routes=routes), flags, num_removed
    approx_destroyed_count = round(destroy_proba * len(routes) + 0.5)
    destroyed_count = min(sol.problem.K, max(1, approx_destroyed_count))

    # Normalize costs to probabilities using temperature
    min_cost = min(costs) if costs else 0.0
    max_cost = max(costs) if costs else 1.0
    cost_range = max_cost - min_cost
    temperature = max(T, 1e-6)

    if cost_range < 1e-6:
        # All routes have similar cost, select uniformly at random
        selected_ids = rng.sample(range(sol.problem.K), destroyed_count)
    else:
        # Collect weights based on normalized costs
        weights = []
        for cost in costs:
            normalized = (cost - min_cost) / cost_range
            weights.append((normalized + 0.1) ** (1.0 / temperature))

        # Select routes based on weights
        selected_ids = []
        available_ids = list(range(sol.problem.K))
        available_weights = weights
        for _ in range(destroyed_count):
            total_weight = sum(available_weights)

            if total_weight < 1e-10:    # All weights zero: pick any subset
                selected_ids.extend(
                    available_ids[:destroyed_count - len(selected_ids)]
                )
                break
            else:                       # Weighted random selection
                selected_idx = sample_from_weight(rng, available_weights)
                selected_ids.append(available_ids[selected_idx])

                # Remove selected index from available
                available_ids.pop(selected_idx)
                available_weights.pop(selected_idx)

                if not available_ids:
                    break


    # Destroy selected routes
    for idx in selected_ids:
        route = routes[idx]

        # Skip empty routes
        if len(route) <= 2:
            continue

        # Update if any nodes were removed
        reduced = destroy_one_route(route, idx, steps=destroy_steps, verbose=False)
        removed = max(0, len(route) - len(reduced))

        if removed > 0:
            routes[idx] = reduced
            flags[idx] = True
            num_removed += removed

    partial_sol = PartialSolution(problem=sol.problem, routes=routes)

    return partial_sol, flags, num_removed

# ----- file share_a_ride/solvers/operator/destroy.py end -----



def greedy_balanced_solver(
        prob: ShareARideProblem,
        premature_routes: List[List[int]] = [],
        verbose: bool = False
    ) -> Tuple[Optional[Solution], Dict[str, Any]]:
    """
    Greedy balanced heuristic:
    - At each step, choose the taxi with smallest current route cost
    - For that taxi, evaluate all feasible next actions (pick/drop).
    - Choose the action with minimal added distance (inc).
    - Repeat until all passengers and parcels are served.

    Returns:
    (sol, info): tuple where
    - sol: Solution object with routes and costs.
    - Info dictionary contains:
        + iterations: number of main loop iterations
        + actions_evaluated: total number of actions evaluated
        + elapsed_time: total time taken
    """

    start_time = time.time()
    partial = PartialSolution(problem=prob, routes=premature_routes)
    taxi_states = partial.route_states

    def has_pending_work() -> bool:
        return partial.remaining_pass_pick \
            or partial.remaining_pass_drop \
            or partial.remaining_parc_pick \
            or partial.remaining_parc_drop

    stats = {"iterations": 0, "actions_evaluated": 0}
    while has_pending_work():
        stats["iterations"] += 1

        available_taxis = [
            t_idx for t_idx, t_state in enumerate(taxi_states)
            if not t_state["ended"]
        ]
        if not available_taxis:
            break

        argmin_t_idx = min(available_taxis, key=lambda i: taxi_states[i]["cost"])
        actions = partial.possible_actions(argmin_t_idx)
        stats["actions_evaluated"] += len(actions)

        if verbose:
            print(f"Taxi with min cost: {argmin_t_idx}")
            print(f"Actions available: {actions}")

        # No feasible actions: return to depot and end route
        if not actions:
            partial.apply_return_to_depot(argmin_t_idx)
            continue

        # Else, choose action with minimal added cost
        kind, idx, inc = min(actions, key=lambda x: x[2])
        partial.apply_action(argmin_t_idx, kind, idx, inc)

        if verbose:
            print(f"Taxi: {argmin_t_idx}: {taxi_states[argmin_t_idx]['route']}\n")


    # All taxis return to depot if not already ended
    for t_idx, t_state in enumerate(taxi_states):
        if not t_state["ended"]:
            partial.apply_return_to_depot(t_idx)

    if verbose:
        print("All tasks completed.")

    # Build final solution
    sol = partial.to_solution()

    # Final stats
    elapsed = time.time() - start_time
    info = {
        "iterations": stats["iterations"],
        "actions_evaluated": stats["actions_evaluated"],
        "elapsed_time": elapsed
    }

    # Validate solution and return
    if sol and not sol.is_valid():
        sol = None
    assert sol.is_valid() if sol else True
    return sol, info


def iterative_greedy_balanced_solver(
        prob: ShareARideProblem,
        iterations: int = 10,
        time_limit: float = 10.0,
        seed: int = 42,
        verbose: bool = False,
        destroy_proba: float = 0.4,
        destroy_steps: int = 15,
        destroy_T: float = 1.0,
        rebuild_proba: float = 0.3,
        rebuild_steps: int = 5,
        rebuild_T: float = 1.0,
    ) -> Tuple[Optional[Solution], Dict[str, Any]]:
    """
    Iterative improvement of greedy balanced heuristic using destroy-and-rebuild.
    At each iteration:
    - Destroy a fraction of routes (randomly selected based on cost)
    - Rebuild those routes partially with some randomness
    - Complete the solution with greedy balanced heuristic
    - If improved, update the best solution found.

    Args:
        - prob: ShareARideProblem instance
        - iterations: Number of destroy-and-rebuild iterations
        - time_limit: Max time allowed (seconds)
        - seed: Random seed for reproducibility
        - verbose: If True, print progress info
        - destroy_proba: Fraction of routes to destroy (0 to 1)
        - destroy_steps: Max number of nodes to remove per route
        - destroy_T: Temperature parameter for destroy operator
        - rebuild_proba: Probability of rebuilding a destroyed route
        - rebuild_steps: Max number of nodes to add during rebuild
        - rebuild_T: Temperature parameter for rebuild operator
    
    Returns:
        (sol, info): tuple where
        - sol: Best Solution found (or None if no valid solution)
        - Info dictionary contains:
            + iterations: number of iterations performed
            + improvements: number of times solution was improved
            + actions_evaluated: total number of actions evaluated
            + nodes_destroyed: total number of nodes removed
            + nodes_rebuilt: total number of nodes added during rebuild
            + elapsed_time: total time taken
            + status: "done" if completed, "timeout" if time limit reached
    """

    assert 1e-5 < destroy_proba < 1 - 1e-5
    assert 1e-5 < rebuild_proba < 1 - 1e-5
    assert 1 <= rebuild_steps <= destroy_steps

    rng = random.Random(seed)
    start_time = time.time()
    deadline = start_time + time_limit if time_limit is not None else None

    # Initial solution and best cost
    best_sol, base_info = greedy_balanced_solver(prob, verbose=False)
    if not best_sol:
        return None, {"elapsed_time": time.time() - start_time, "status": "error"}
    best_cost = best_sol.max_cost

    # Stats
    total_actions = base_info["actions_evaluated"]
    improvements = 0
    nodes_destroyed = 0
    nodes_rebuilt = 0
    status = "done"
    iterations_done = 0


    if verbose:
        print(f"[iter 0] initial best cost: {best_cost}")


    # ================= Main loop =================
    for it in range(1, iterations + 1):
        if deadline and time.time() >= deadline:
            status = "timeout"
            break
        iterations_done += 1

        # ============== Destroy phase ==============
        destroy_seed = (2 * seed + it) if seed is not None else None
        partial_sol, destroyed_flags, removed = destroy_operator(
            best_sol,
            destroy_proba,
            destroy_steps,
            seed=destroy_seed,
            T=destroy_T
        )
        nodes_destroyed += removed

        # ============= Temporary rebuild phase ==============
        for r_idx, was_destroyed in enumerate(destroyed_flags):
            if not was_destroyed or len(partial_sol.routes[r_idx]) <= 2:
                continue
            if rng.random() > rebuild_proba:
                continue

            partial_sol, new_nodes_count = build_operator(
                partial_sol,
                route_idx=r_idx,
                steps=rebuild_steps,
                T=rebuild_T,
                seed=(destroy_seed + r_idx) if destroy_seed is not None else None,
                verbose=False
            )
            nodes_rebuilt += new_nodes_count

        # ============== Greedy build phase ==============
        sol_cand, info_cand = greedy_balanced_solver(
            prob,
            premature_routes=partial_sol.routes,
            verbose=False
        )

        total_actions += info_cand["actions_evaluated"]

        # If improved, update best solution
        if (sol_cand and sol_cand.is_valid()
            and sol_cand.max_cost < best_cost
        ):
            best_sol = sol_cand
            best_cost = sol_cand.max_cost
            improvements += 1

            if verbose:
                print(f"[iter {it}] improved best to {best_cost}")


    # Final stats
    elapsed = time.time() - start_time
    info = {
        "iterations": iterations_done,
        "improvements": improvements,
        "actions_evaluated": total_actions,
        "nodes_destroyed": nodes_destroyed,
        "nodes_rebuilt": nodes_rebuilt,
        "elapsed_time": elapsed,
        "status": status,
    }

    return best_sol, info

# ----- file share_a_ride/solvers/algo/greedy.py end -----

# ----- file share_a_ride/utils/generator.py begin -----



def read_instance() -> tuple:
    """
    Read instance from standard input.
    """

    N, M, K = map(int, sys.stdin.readline().strip().split())
    q = list(map(int, sys.stdin.readline().split()))
    Q = list(map(int, sys.stdin.readline().split()))
    D = [[0] * (2 * N + 2 * M + 1) for _ in range(2 * N + 2 * M + 1)]
    for r in range(2 * N + 2 * M + 1):
        line = sys.stdin.readline().strip()
        D[r] = list(map(int, line.split()))

    return ShareARideProblem(N, M, K, q, Q, D)

def main():
    prob: ShareARideProblem = read_instance()
    sol, info1 = iterative_greedy_balanced_solver(
        prob=prob, 
        iterations=10000, time_limit=10.0, seed=42, verbose=0,
        destroy_proba=0.5, destroy_steps=min(6, prob.num_nodes // (2 * prob.K) + 1), destroy_T=1.0,
        rebuild_proba=0.3, rebuild_steps=2, rebuild_T=5.0
    )

    # print(f"Enumeration info: {info1}")
    sol.stdin_print(verbose=0)


    # sol_list3, info3 = exhaustive_enumerate(
    #     prob, max_solutions=500000,time_limit=10.0, verbose=True
    # )
    # if sol_list3:
    #     sol_list3[0].pretty_print(verbose=1)
    # print("Enumeration info:", info3)
    # print(route_cost_from_sequence(sol_list3[0].routes[0], prob.D, verbose=1))


if __name__ == "__main__":
    main()

# ----- file oj.py end -----
