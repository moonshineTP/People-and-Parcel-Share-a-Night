"""
Module defining the Share-a-Ride Problem (SARP) class and related functionalities.
"""
from __future__ import annotations
from typing import Optional
from typing import TYPE_CHECKING


if TYPE_CHECKING:
    import matplotlib.pyplot as plt


class ShareARideProblem:
    def __init__(
            self, N: int, M: int, K: int,
            parcel_qty: list[int], vehicle_caps: list[int],
            dist: list[list[int]], coords: Optional[list[tuple[int, int]]] = None
        ):

        # Basic parameters
        self.N = N
        self.M = M
        self.K = K
        self.q = list(parcel_qty)
        self.Q = list(vehicle_caps)
        self.D = [row[:] for row in dist]
        self.num_nodes = 2*N + 2*M + 1
        self.num_requests = N + M

        # index helpers
        self.ppick = lambda i: i
        self.pdrop = lambda i: N + M + i
        self.parc_pick = lambda j: N + j
        self.parc_drop = lambda j: 2*N + M + j

        self.rev_ppick = lambda i: i
        self.rev_pdrop = lambda n: n - (N + M)
        self.rev_parc_pick = lambda n: n - N
        self.rev_parc_drop = lambda n: n - (2 * N + M)

        # Node check helpers
        self.is_ppick = lambda x: 1 <= x <= N
        self.is_pdrop = lambda x: N + M + 1 <= x <= 2 * N + M
        self.is_parc_pick = lambda x: N + 1 <= x <= N + M
        self.is_parc_drop = lambda x: 2 * N + M + 1 <= x <= 2 * (N + M)

        # Coordinate (mainly for visualization)
        self.coords = coords


    def is_valid(self) -> bool:
        try:
            assert len(self.q) == self.M
            assert len(self.Q) == self.K
            assert len(self.D) == self.num_nodes
            assert all(len(row) == self.num_nodes for row in self.D)
            assert len(self.coords) == self.num_nodes \
                if self.coords is not None else True

            return True
        except:
            return False

    def copy(self):
        return ShareARideProblem(self.N, self.M, self.K,
            list(self.q), list(self.Q), [row[:] for row in self.D]
        )


    def stdin_print(self):
        print(self.N, self.M, self.K)
        print(*self.q)
        print(*self.Q)
        for row in self.D:
            print(*row)


    def pretty_print(self, verbose: bool = False):
        print(f"Share-a-Ride: N={self.N} passengers, M={self.M} parcels, "
            f"K={self.K}, num_nodes={self.num_nodes}")

        if verbose >= 1:
            print("Parcel quantities (q):", self.q)
            print("Vehicle capacities (Q):", self.Q)
            print("Distance matrix D:")
            for row in self.D:
                print(" ", row)


    def to_sarp_text(self) -> str:
        dimension = self.num_nodes

        if not self.is_valid():
            raise ValueError("Instance data is invalid.")
        if self.coords is None:
            raise ValueError("Coordinates are required for SARP text export.")

        name = getattr(self, "name", "Generated_SARP")
        comment = getattr(self, "comment", f"Generated by 'share_a_ride.util.generator. "
                            f"Node count: N={self.N}, M={self.M}, K={self.K}")

        lines: list[str] = []
        lines.append(f"NAME : {name}")
        lines.append(f"COMMENT : {comment}")
        lines.append("TYPE : SARP")
        lines.append(f"DIMENSION : {dimension}")
        lines.append("EDGE_WEIGHT_TYPE : EXPLICIT")
        lines.append("EDGE_WEIGHT_FORMAT : FULL_MATRIX")
        if len(set(self.Q)) == 1:
            lines.append(f"CAPACITY : {self.Q[0]}")

        lines.append("")
        lines.append("EDGE_WEIGHT_SECTION")
        for row in self.D:
            lines.append(" ".join(str(value) for value in row))
        lines.append("EOF_EDGE_WEIGHT_SECTION")

        lines.append("")
        lines.append("NODE_COORD_SECTION")
        for idx, (x, y) in enumerate(self.coords, start=1):
            lines.append(f"{idx} {x} {y}")
        lines.append("EOF_NODE_COORD_SECTION")

        lines.append("")
        lines.append("NODE_TYPE_SECTION")
        for idx in range(dimension):
            node_id = idx + 1
            if idx == 0:
                node_type = 0
            elif self.is_ppick(idx):
                node_type = 1
            elif self.is_parc_pick(idx):
                node_type = 2
            elif self.is_pdrop(idx):
                node_type = 3
            elif self.is_parc_drop(idx):
                node_type = 4
            else:
                raise ValueError("Invalid node index encountered.")

            lines.append(f"{node_id} {node_id} {node_type}")
        lines.append("EOF_NODE_TYPE_SECTION")

        lines.append("")
        lines.append("PAIR_SECTION")
        pair_id = 1
        for i in range(1, self.N + 1):
            pickup = self.ppick(i) + 1
            drop = self.pdrop(i) + 1
            lines.append(f"{pair_id} {pickup} P {drop}")
            pair_id += 1
        for j in range(1, self.M + 1):
            pickup = self.parc_pick(j) + 1
            drop = self.parc_drop(j) + 1
            lines.append(f"{pair_id} {pickup} L {drop}")
            pair_id += 1
        lines.append("EOF_PAIR_SECTION")

        lines.append("")
        lines.append("VEHICLE_CAPACITY_SECTION")
        for vehicle_id, cap in enumerate(self.Q, start=1):
            lines.append(f"{vehicle_id} {vehicle_id} {cap}")
        lines.append("EOF_VEHICLE_CAPACITY_SECTION")

        lines.append("")
        lines.append("PARCEL_QUANTITY_SECTION")
        for idx, qty in enumerate(self.q, start=1):
            pickup = self.parc_pick(idx) + 1
            lines.append(f"{idx} {pickup} {qty}")
        lines.append("EOF_PARCEL_QUANTITY_SECTION")

        lines.append("")
        lines.append("DEPOT_SECTION")
        lines.append("1")
        lines.append("EOF_DEPOT_SECTION")

        lines.append("")
        lines.append("EOF")

        return "\n".join(lines) + "\n"


    def visualize(self, ax = None) -> None:
        """
        Visualize the problem instance (nodes) on the given Axes.
        If no Axes provided, creates a new figure and its Axes.
        You should import matplotlib.pyplot as plt before using this function.
        """
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            print("matplotlib is required for visualization.")
            return

        if self.coords is None:
            print("No coordinates available for visualization.")
            return

        only_show = False
        if ax is None:
            only_show = True
            plt.figure(figsize=(6,6))
            ax = plt.gca()

        styles = {
            "depot": {"marker": "s", "color": "black", "label": "Depot"},
            "ppick": {"marker": "o", "color": "tab:blue", "label": "Passenger pickup"},
            "pdrop": {"marker": "o", "color": "tab:cyan", "label": "Passenger drop"},
            "parc_pick": {"marker": "^", "color": "tab:orange", "label": "Parcel pickup"},
            "parc_drop": {"marker": "^", "color": "tab:olive", "label": "Parcel drop"},
        }

        legend_handles = {}
        for idx, (x, y) in enumerate(self.coords):
            if idx == 0:
                style_key = "depot"
            elif self.is_ppick(idx):
                style_key = "ppick"
            elif self.is_parc_pick(idx):
                style_key = "parc_pick"
            elif self.is_pdrop(idx):
                style_key = "pdrop"
            elif self.is_parc_drop(idx):
                style_key = "parc_drop"
            else:
                continue

            scatter = ax.scatter(
                x, y,
                marker=styles[style_key]["marker"],
                color=styles[style_key]["color"],
                label=styles[style_key]["label"],
            )
            if style_key not in legend_handles:
                legend_handles[style_key] = scatter
            ax.text(x, y, str(idx), fontsize=8, ha="left", va="bottom")


        ax.set_title("Share-a-Ride Instance")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        if legend_handles:
            ax.legend(
                handles=legend_handles.values(),
                labels=[styles[key]["label"] for key in legend_handles],
                loc="upper left",
                bbox_to_anchor=(1.02, 1),
                fontsize=8,
                frameon=True,
            )
        ax.axis("equal")
        ax.grid(True, linestyle="--", color="gray", alpha=0.2)

        if only_show:
            plt.show()
