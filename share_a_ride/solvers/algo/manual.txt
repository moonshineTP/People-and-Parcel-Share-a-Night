Manual developer guide for algorithm modules.

This document provides guidance for developers working on the algorithm modules of the Share-a-Ride optimization project.
It outlines best practices, coding standards, and key considerations to ensure consistency and maintainability across the codebase.

1. Coding Standards
- Follow PEP 8 style guidelines for Python code.
- Use meaningful variable and function names.
- Include docstrings for all functions and classes to explain their purpose and usage.

2. Module Structure
- Each algorithm should reside in its own module within the `share_a_ride/solvers/algo/` directory.
- Each module should contain:
  - A main solver/enumerator function that implements the algorithm.
  - Helper functions as needed, encapsulated within the module.

3. Signature
- All solver functions should accept a `problem` instance and a `partial` PartialSolution instance
or `swarm` PartialSolutionSwarm instance as parameters. This is crucial to kickstart the algorithm
with the current state of the solution.
- Return a complete Solution instance along with any relevant metadata (e.g., performance metrics).
- Has three optional parameters: `seed`, `time_limit`, and `verbose`.
  - `seed`: An integer to initialize the random number generator for reproducibility.
  - `time_limit`: A float specifying the maximum time (in seconds) the algorithm should run.
  - `verbose`: A boolean flag to enable detailed logging during execution.
- Common parameters for solvers:
  - `iterations`: Maximum number of iterations (runs/refinements) to perform.
  - `width`: Beam width as a nearest neighbor consideration.
  - `n_partials`: Number of partial solutions to maintain in swarm-based approaches.
  - `cutoff_depth`: The periodic depth limit to perform pruning the tree or the heap in exploration-based algorithms.

4. Randomness and Reproducibility
- Use the provided `seed` parameter to initialize any random number generators.
- Ensure that any stochastic elements of the algorithm can be reproduced by using the same seed.

5. Performance Considerations
- Optimize for both time and space complexity where possible.
- Profile and benchmark algorithms to identify bottlenecks.
